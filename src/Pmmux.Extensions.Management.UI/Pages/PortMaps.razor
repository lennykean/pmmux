@page "/port-maps"
@using Pmmux.Extensions.Management.Models
@using Pmmux.Extensions.Management.UI.Services
@using Mono.Nat
@inject PmmuxApiClient ApiClient

<PageTitle>Port Forwarding - Pmmux</PageTitle>

<div class="card">
  <div class="card-header">
    <div class="card-header__content">
      <h2 class="card-header__title">Port Forwarding</h2>
      @if (natDevice != null)
      {
        <p class="card-header__subtitle nat-device-info">
          NAT Device: <code title="NAT device public address">@natDevice.PublicAddress</code>
          <span class="nat-badge" title="NAT device protocol">@natDevice.NatProtocol</span>
        </p>
      }
      else
      {
        <p class="card-header__subtitle nat-device-info nat-device-info--none">No NAT device detected</p>
      }
    </div>
    <div class="card-header__actions">
      <button class="btn btn--primary" @onclick="OpenAddModal">
        <i class="ph ph-plus"></i>
        Add Port Map
      </button>
    </div>
  </div>
  <div class="card-body card-body--no-padding">
    @if (loading && portMaps.Count == 0)
    {
      <div class="loading-state">Loading port maps...</div>
    }
    else if (error != null)
    {
      <div class="error-state">@error</div>
    }
    else if (portMaps.Count == 0)
    {
      <div class="empty-state">
        <div class="empty-state__icon">
          <i class="ph ph-arrows-split"></i>
        </div>
        <h3 class="empty-state__title">No port maps configured</h3>
        <p class="empty-state__description">
          Add port maps to expose local services through NAT/UPnP port forwarding.
        </p>
        <button class="btn btn--primary" @onclick="OpenAddModal">Add Port Map</button>
      </div>
    }
    else
    {
      <div class="table-wrapper">
        <table class="table">
          <thead class="table-head">
            <tr class="table-row">
              <th class="table-header">Protocol</th>
              <th class="table-header">Local Port</th>
              <th class="table-header">Public Address</th>
              <th class="table-header">Public Port</th>
              <th class="table-header table-cell--right">Actions</th>
            </tr>
          </thead>
          <tbody class="table-body">
            @foreach (var portMap in portMaps)
            {
              var key = $"{portMap.NetworkProtocol}:{portMap.LocalPort}:{portMap.PublicPort}";
              <tr class="table-row" @key="key">
                <td class="table-cell">
                  <span class="protocol-badge">@portMap.NetworkProtocol</span>
                </td>
                <td class="table-cell">
                  <code>@portMap.LocalPort</code>
                </td>
                <td class="table-cell">
                  <code>@(portMap.PublicAddress ?? "-")</code>
                </td>
                <td class="table-cell">
                  <code>@portMap.PublicPort</code>
                </td>
                <td class="table-cell table-cell--right">
                  <button class="btn btn--danger btn--sm" @onclick="() => ConfirmDelete(portMap)"
                    disabled="@(deleting == key)">
                    @if (deleting == key)
                    {
                      <span class="loading-spinner"></span>
                    }
                    Delete
                  </button>
                </td>
              </tr>
            }
          </tbody>
        </table>
      </div>
    }
  </div>
</div>

@if (showAddModal)
{
  <div class="modal-overlay" @onclick="CloseAddModal">
    <div class="modal" @onclick:stopPropagation="true">
      <div class="modal-header">
        <h3 class="modal-title">Add Port Map</h3>
      </div>
      <div class="modal-body">
        @if (modalError != null)
        {
          <div class="modal-error">@modalError</div>
        }
        <div class="form-group">
          <label class="form-label">Protocol</label>
          <select class="form-select" @bind="newProtocol" @bind:after="OnProtocolChanged">
            <option value="@Protocol.Tcp">TCP</option>
            <option value="@Protocol.Udp">UDP</option>
          </select>
        </div>
        <div class="form-checkbox-group">
          <input class="form-checkbox" type="checkbox" id="autoLocalPort" checked="@autoLocalPort"
            @onchange="e => { autoLocalPort = (bool)(e.Value ?? false); if (autoLocalPort) createListener = true; }" />
          <label class="form-checkbox-label" for="autoLocalPort">Auto-assign local port</label>
        </div>

        @if (!autoLocalPort)
        {
          <div class="form-group">
            <label class="form-label">Local Port</label>
            <input class="form-input" type="text" placeholder="8080" @bind="newLocalPort" @bind:event="oninput"
              @bind:after="OnLocalPortChanged" />
            @if (ParsedLocalPort > 0 && !ListenerExists)
            {
              <p class="form-hint form-hint--warning">
                <i class="ph ph-warning"></i>
                No listener on @newProtocol :@newLocalPort
              </p>
            }
          </div>
        }

        <div
          class="form-checkbox-group @(!autoLocalPort && (ParsedLocalPort <= 0 || ListenerExists) ? "form-checkbox-group--disabled" : "")">
          <input class="form-checkbox" type="checkbox" id="createListener" checked="@createListener"
            disabled="@(!autoLocalPort && (ParsedLocalPort <= 0 || ListenerExists))"
            @onchange="e => createListener = (bool)(e.Value ?? false)" />
          <label class="form-checkbox-label" for="createListener">
            @if (autoLocalPort)
            {
              <span>Create listener on assigned local port</span>
            }
            else if (ParsedLocalPort > 0)
            {
              @if (ListenerExists)
              {
                <span>Listener already exists on port @ParsedLocalPort</span>
              }
              else
              {
                <span>Create listener for @newProtocol :@newLocalPort</span>
              }
            }
            else
            {
              <span>Create listener</span>
            }
          </label>
        </div>

        @if (createListener)
        {
          <div class="form-group">
            <label class="form-label">Bind Address</label>
            <input class="form-input" type="text" placeholder="0.0.0.0" @bind="newBindAddress" @bind:event="oninput" />
            <p class="form-hint">IP address to bind to. Leave empty for all interfaces (0.0.0.0).</p>
          </div>
        }

        <hr class="form-divider" />

        <div class="form-checkbox-group">
          <input class="form-checkbox" type="checkbox" id="autoPublicPort" checked="@autoPublicPort"
            @onchange="e => autoPublicPort = (bool)(e.Value ?? false)" />
          <label class="form-checkbox-label" for="autoPublicPort">Auto-assign public port</label>
        </div>
        @if (!autoPublicPort)
        {
          <div class="form-group">
            <label class="form-label">Public Port</label>
            <input class="form-input" type="text" placeholder="8080" @bind="newPublicPort" @bind:event="oninput" />
          </div>
        }
      </div>
      <div class="modal-footer">
        <button class="btn btn--secondary" @onclick="CloseAddModal">Cancel</button>
        <button class="btn btn--primary" @onclick="HandleAdd"
          disabled="@(adding || (!autoLocalPort && ParsedLocalPort <= 0) || (!autoPublicPort && ParsedPublicPort <= 0))">
          @if (adding)
          {
            <span class="loading-spinner"></span>
          }
          Add Port Map
        </button>
      </div>
    </div>
  </div>
}

@if (showConfirmModal)
{
  <div class="modal-overlay" @onclick="() => showConfirmModal = false">
    <div class="modal" @onclick:stopPropagation="true">
      <div class="modal-header">
        <h3 class="modal-title">No Listener</h3>
      </div>
      <div class="modal-body">
        <div class="confirm-content">
          <p>No listeners are configured for port <strong>@newLocalPort</strong>. Pmmux will manage the port mapping but
            won't receive the traffic.</p>
          <p>Is this intentional?</p>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn--secondary" @onclick="() => showConfirmModal = false">Cancel</button>
        <button class="btn btn--primary" @onclick="DoAdd" disabled="@adding">
          @if (adding)
          {
            <span class="loading-spinner"></span>
          }
          Yes, Continue
        </button>
      </div>
    </div>
  </div>
}

@if (deleteTarget != null)
{
  <div class="modal-overlay" @onclick="CancelDelete">
    <div class="modal" @onclick:stopPropagation="true">
      <div class="modal-header">
        <h3 class="modal-title">Delete Port Map</h3>
      </div>
      <div class="modal-body">
        @if (modalError != null)
        {
          <div class="modal-error">@modalError</div>
        }
        <div class="confirm-content">
          <p>Delete port map for <strong>@deleteTarget.LocalPort</strong>?</p>
          <p>Traffic on public port <strong>@deleteTarget.PublicPort</strong> will no longer be forwarded to local port
            <strong>@deleteTarget.LocalPort</strong>.
          </p>
        </div>
      </div>
      <div class="modal-footer">
        <button class="btn btn--secondary" @onclick="CancelDelete">Cancel</button>
        <button class="btn btn--danger" @onclick="DeletePortMap">Delete</button>
      </div>
    </div>
  </div>
}

@code {
  private List<PortMapInfoDto> portMaps = new();
  private List<ListenerInfoDto> listeners = new();
  private NatDeviceInfoDto? natDevice = null;
  private bool loading = true;
  private string? error = null;
  private string? modalError = null;
  private bool showAddModal = false;
  private bool showConfirmModal = false;
  private bool adding = false;
  private string? deleting = null;
  private PortMapInfoDto? deleteTarget = null;

  private Protocol newProtocol = Protocol.Tcp;
  private string newLocalPort = "";
  private string newPublicPort = "";
  private string newBindAddress = "";
  private bool autoLocalPort = false;
  private bool createListener = false;
  private bool autoPublicPort = true;

  private System.Timers.Timer? refreshTimer;

  private int ParsedLocalPort => int.TryParse(newLocalPort, out var p) ? p : 0;
  private int ParsedPublicPort => int.TryParse(newPublicPort, out var p) ? p : 0;

  private bool ListenerExists => ParsedLocalPort > 0 && listeners.Any(l =>
  l.NetworkProtocol == newProtocol && l.Port == ParsedLocalPort);

  protected override async Task OnInitializedAsync()
  {
    await LoadPortMaps();
    StartAutoRefresh();
  }

  private async Task LoadPortMaps()
  {
    try
    {
      loading = true;
      error = null;
      var portMapsTask = ApiClient.GetPortMapsAsync();
      var natDeviceTask = ApiClient.GetNatDeviceAsync();
      portMaps = await portMapsTask;
      natDevice = await natDeviceTask;
    }
    catch (Exception ex)
    {
      error = ex.Message;
    }
    finally
    {
      loading = false;
      StateHasChanged();
    }
  }

  private void StartAutoRefresh()
  {
    refreshTimer = new System.Timers.Timer(10000);
    refreshTimer.Elapsed += async (sender, e) => await LoadPortMaps();
    refreshTimer.Start();
  }

  private async Task OpenAddModal()
  {
    modalError = null;
    try
    {
      listeners = await ApiClient.GetListenersAsync();
    }
    catch
    {
      listeners = new();
    }
    ResetForm();
    showAddModal = true;
  }

  private void CloseAddModal()
  {
    showAddModal = false;
    modalError = null;
    ResetForm();
  }

  private void ResetForm()
  {
    newProtocol = Protocol.Tcp;
    newLocalPort = "";
    newPublicPort = "";
    newBindAddress = "";
    autoLocalPort = false;
    createListener = false;
    autoPublicPort = true;
  }

  private void OnProtocolChanged()
  {
    createListener = false;
  }

  private void OnLocalPortChanged()
  {
    createListener = false;
  }

  private void HandleAdd()
  {
    if (!autoLocalPort && !ListenerExists && !createListener)
    {
      showConfirmModal = true;
      return;
    }
    _ = DoAdd();
  }

  private async Task DoAdd()
  {
    showConfirmModal = false;
    try
    {
      adding = true;
      modalError = null;

      var response = await ApiClient.CreatePortMapAsync(new PortMapRequest
      {
        NetworkProtocol = newProtocol,
        LocalPort = autoLocalPort ? null : ParsedLocalPort,
        PublicPort = autoPublicPort ? null : ParsedPublicPort,
        CreateListener = false
      });

      if (autoLocalPort && createListener && response != null)
      {
        await ApiClient.CreateListenerAsync(new ListenerRequest
        {
          NetworkProtocol = newProtocol,
          Port = response.LocalPort,
          BindAddress = string.IsNullOrWhiteSpace(newBindAddress) ? null : newBindAddress
        });
      }
      else if (!autoLocalPort && createListener && !ListenerExists)
      {
        await ApiClient.CreateListenerAsync(new ListenerRequest
        {
          NetworkProtocol = newProtocol,
          Port = ParsedLocalPort,
          BindAddress = string.IsNullOrWhiteSpace(newBindAddress) ? null : newBindAddress
        });
      }

      CloseAddModal();
      await LoadPortMaps();
    }
    catch (Exception ex)
    {
      modalError = GetErrorMessage(ex);
    }
    finally
    {
      adding = false;
    }
  }

  private void ConfirmDelete(PortMapInfoDto portMap)
  {
    modalError = null;
    deleteTarget = portMap;
  }

  private void CancelDelete()
  {
    deleteTarget = null;
    modalError = null;
  }

  private async Task DeletePortMap()
  {
    if (deleteTarget == null)
    {
      return;
    }

    var key = $"{deleteTarget.NetworkProtocol}:{deleteTarget.LocalPort}:{deleteTarget.PublicPort}";

    try
    {
      deleting = key;
      modalError = null;
      await ApiClient.DeletePortMapAsync(deleteTarget.NetworkProtocol, deleteTarget.LocalPort, deleteTarget.PublicPort);
      deleteTarget = null;
      await LoadPortMaps();
    }
    catch (Exception ex)
    {
      modalError = GetErrorMessage(ex);
    }
    finally
    {
      deleting = null;
    }
  }

  private static string GetErrorMessage(Exception ex)
  {
    if (ex is PmmuxApiClient.ApiException apiEx)
    {
      return apiEx.Message;
    }

    var message = ex.Message;
    if (ex.GetType().Name == "JSException" && message.Contains("Failed to fetch"))
    {
      return "Unable to connect to the server";
    }
    if (ex is HttpRequestException)
    {
      return "Server error";
    }
    return string.IsNullOrWhiteSpace(message) ? "An unexpected error occurred" : message;
  }

  public void Dispose()
  {
    refreshTimer?.Dispose();
  }
}
